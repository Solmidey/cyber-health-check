generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

model Tenant {
  id        String   @id
  plan      String
  createdAt DateTime @default(now())

  users     User[]
  devices   Device[]
  events    Event[]
  incidents Incident[]

  notificationChannels     NotificationChannel[]
  notificationDeliveries   NotificationDelivery[]
  notificationRules        NotificationRule[]
  notificationSuppressions NotificationSuppression[]
}

model User {
  id        String   @id
  tenantId  String
  createdAt DateTime @default(now())

  tenant  Tenant   @relation(fields: [tenantId], references: [id])
  devices Device[]
  events  Event[]
}

model Device {
  id        String   @id
  tenantId  String
  userId    String
  createdAt DateTime @default(now())

  tenant Tenant  @relation(fields: [tenantId], references: [id])
  user   User    @relation(fields: [userId], references: [id])
  events Event[]
}

model Event {
  id        String   @id @default(cuid())
  tenantId  String
  userId    String
  deviceId  String
  type      String
  url       String
  hostname  String
  risk      Int
  verdict   String
  reasons   String[]
  ts        DateTime
  createdAt DateTime @default(now())

  tenant Tenant @relation(fields: [tenantId], references: [id])
  user   User   @relation(fields: [userId], references: [id])
  device Device @relation(fields: [deviceId], references: [id])

  @@index([tenantId, ts])
  @@index([tenantId, hostname])
  @@index([tenantId, verdict])
}

model Incident {
  id          String   @id @default(cuid())
  tenantId    String
  hostname    String
  verdict     String
  maxRisk     Int
  reasons     String[]
  firstSeenAt DateTime
  lastSeenAt  DateTime
  eventCount  Int      @default(1)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id])

  @@unique([tenantId, hostname, verdict])
  @@index([tenantId, lastSeenAt])
}

enum NotificationChannelType {
  slack
  email
  webhook
}

enum NotificationDeliveryStatus {
  pending
  sent
  failed
  skipped
}

model NotificationChannel {
  id       String                  @id @default(cuid())
  tenantId String
  type     NotificationChannelType
  name     String?
  enabled  Boolean                 @default(true)

  // channel-specific config:
  // slack:   { webhookUrl: string }
  // email:   { to: string, from?: string }
  // webhook: { url: string, secret?: string }
  config Json

  // optional filters:
  // { minRisk?: number, verdicts?: ("warn"|"block")[], eventTypes?: ("NAVIGATE"|"DOWNLOAD")[] }
  filters Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant     Tenant                 @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  deliveries NotificationDelivery[]

  // inverse relation for NotificationRuleChannel.channel
  ruleLinks NotificationRuleChannel[]

  @@index([tenantId])
}

model NotificationDelivery {
  id           String                     @id @default(cuid())
  tenantId     String
  channelId    String
  kind         String // "incident_created" | "incident_digest" | etc.
  status       NotificationDeliveryStatus @default(pending)
  attemptCount Int                        @default(0)
  lastError    String?
  payload      Json
  createdAt    DateTime                   @default(now())
  sentAt       DateTime?

  // âœ… retry scheduling
  nextAttemptAt DateTime?
  lastAttemptAt DateTime?

  tenant  Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  channel NotificationChannel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@index([tenantId, createdAt])
  @@index([channelId, createdAt])
  @@index([status, nextAttemptAt])
}

enum NotificationMode {
  immediate
  digest
}

model NotificationRule {
  id       String @id @default(cuid())
  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  name    String
  enabled Boolean          @default(true)
  mode    NotificationMode @default(immediate)

  // Conditions (optional; if empty => matches)
  minRisk    Int?
  verdicts   String[] // ["warn","block"]
  eventTypes String[] // ["NAVIGATE","DOWNLOAD"]

  // Host routing controls
  hostAllow String[] // if non-empty, only these hosts match
  hostDeny  String[] // if contains host, rule won't match

  channels NotificationRuleChannel[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([tenantId, enabled])
  @@index([tenantId, createdAt])
}

model NotificationRuleChannel {
  ruleId    String
  channelId String

  rule    NotificationRule    @relation(fields: [ruleId], references: [id], onDelete: Cascade)
  channel NotificationChannel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@id([ruleId, channelId])
  @@index([channelId])
}

/**
 * Mute/suppression (top-tier UX):
 * - prevents alert fatigue for noisy hosts
 * - engine writes `skipped` deliveries for audit
 */
model NotificationSuppression {
  id         String   @id @default(cuid())
  tenantId   String
  hostname   String
  mutedUntil DateTime
  reason     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([tenantId, hostname])
  @@index([tenantId, mutedUntil])
}
